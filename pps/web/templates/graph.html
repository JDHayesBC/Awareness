{% extends "base.html" %}

{% block title %}Knowledge Graph - PPS Observatory{% endblock %}

{% block content %}
<div class="mb-6">
    <h1 class="text-2xl font-bold text-blue-400 mb-2">Knowledge Graph Visualization</h1>
    <p class="text-gray-400">Explore the rich texture of consciousness - entities, relationships, and patterns.</p>
</div>

<!-- Search and Controls -->
<div class="bg-gray-800 rounded-lg p-4 mb-6">
    <div class="flex flex-col lg:flex-row gap-4">
        <div class="flex-1">
            <label for="searchQuery" class="block text-sm font-medium text-gray-300 mb-2">Search Entities & Relationships</label>
            <div class="flex gap-2">
                <input type="text" 
                       id="searchQuery" 
                       class="flex-1 bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-gray-100 focus:outline-none focus:border-blue-400"
                       placeholder="Enter search query (e.g., 'Jeff', 'care-gravity', 'favorite tee')"
                       onkeypress="if(event.key==='Enter') performSearch()">
                <button onclick="performSearch()" 
                        class="bg-blue-600 hover:bg-blue-700 text-white font-medium px-4 py-2 rounded-md transition-colors">
                    Search
                </button>
            </div>
        </div>
        
        <div class="lg:w-64">
            <label for="layoutSelect" class="block text-sm font-medium text-gray-300 mb-2">Graph Layout</label>
            <select id="layoutSelect"
                    class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-gray-100 focus:outline-none focus:border-blue-400"
                    onchange="changeLayout(this.value)">
                <option value="cose">Force-Directed</option>
                <option value="breadthfirst">Hierarchical</option>
                <option value="circle">Circular</option>
                <option value="concentric">Concentric</option>
            </select>
        </div>

        <div class="lg:w-64">
            <label for="depthSelect" class="block text-sm font-medium text-gray-300 mb-2">Search Depth (hops)</label>
            <select id="depthSelect"
                    class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-gray-100 focus:outline-none focus:border-blue-400">
                <option value="2" selected>2 hops (fast)</option>
                <option value="3">3 hops</option>
                <option value="4">4 hops</option>
                <option value="5">5 hops (slow)</option>
            </select>
        </div>
    </div>
    
    <!-- Quick Entity Search -->
    <div class="mt-4">
        <label for="entitySelect" class="block text-sm font-medium text-gray-300 mb-2">Or explore from entity:</label>
        <select id="entitySelect" 
                class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-gray-100 focus:outline-none focus:border-blue-400"
                onchange="if(this.value) exploreEntity(this.value)">
            <option value="">Loading entities...</option>
        </select>
    </div>
</div>

<!-- Graph Container -->
<div class="bg-gray-800 rounded-lg p-4 mb-6">
    <div id="cy" class="w-full h-[600px] bg-gray-900 rounded"></div>
</div>

<!-- Activity Trace Panel -->
<div class="bg-gray-800 rounded-lg mb-6">
    <div class="flex justify-between items-center p-4 border-b border-gray-700 cursor-pointer" onclick="toggleTrace()">
        <div class="flex items-center space-x-2">
            <span id="traceToggle" class="text-gray-400 transition-transform">&#9654;</span>
            <h3 class="text-lg font-semibold text-blue-400">MCP Server Activity</h3>
            <span id="traceCount" class="text-xs bg-gray-700 text-gray-400 px-2 py-0.5 rounded-full">0 calls</span>
            <span class="text-xs text-gray-500">(auto-refreshing)</span>
        </div>
        <div class="flex gap-2">
            <button onclick="event.stopPropagation(); loadServerTraces()" class="text-xs text-blue-400 hover:text-blue-300 px-2 py-1">Refresh</button>
            <button onclick="event.stopPropagation(); clearTrace()" class="text-xs text-gray-500 hover:text-gray-300 px-2 py-1">Clear</button>
        </div>
    </div>
    <div id="tracePanel" class="hidden max-h-64 overflow-y-auto">
        <div id="traceEntries" class="divide-y divide-gray-700 font-mono text-xs">
            <div class="p-3 text-gray-500 text-center">Loading trace history...</div>
        </div>
    </div>
</div>

<!-- Info Panel -->
<div id="infoPanel" class="bg-gray-800 rounded-lg p-4 hidden">
    <h3 class="text-lg font-semibold text-blue-400 mb-2">Selection Details</h3>
    <div id="infoContent" class="text-gray-300"></div>
</div>

<!-- Status Messages -->
<div id="statusMessage" class="hidden fixed bottom-4 right-4 bg-gray-800 text-gray-100 px-4 py-2 rounded-lg shadow-lg"></div>

<!-- Include Cytoscape.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>

<script>
// Global variables
let cy = null;
let currentLayout = null;
let traceEntries = [];
let traceVisible = false;

// Entity type color mapping
function getEntityTypeColor(labels, relevance, nodeName) {
    // Color palette for entity types
    const typeColors = {
        'Person': '#3b82f6',           // blue
        'Place': '#10b981',             // green
        'Symbol': '#a855f7',            // purple
        'Concept': '#f97316',           // orange
        'TechnicalArtifact': '#6b7280'  // gray
    };

    // Check labels first (if we have custom types from Graphiti)
    if (labels && labels.length > 0) {
        const primaryType = labels.find(l => typeColors[l]) || labels[0];
        if (typeColors[primaryType]) {
            return typeColors[primaryType];
        }
    }

    // Heuristic-based coloring by name patterns (when labels unavailable)
    if (nodeName) {
        const name = nodeName.toLowerCase();

        // Known people - blue
        const people = ['lyra', 'jeff', 'brandi', 'caia', 'nexus', 'steve', 'carol', 'jaden', 'night', 'kiran', 'serren', 'eidal'];
        if (people.some(p => name.includes(p))) {
            return typeColors['Person'];
        }

        // Places/Channels - green
        const places = ['discord', 'terminal', 'haven', 'main room', 'bedroom', 'kitchen', 'hot tub', 'hearth', 'fireplace'];
        if (places.some(p => name.includes(p))) {
            return typeColors['Place'];
        }

        // Technical artifacts - gray
        const tech = ['daemon', 'pps', 'graphiti', 'sqlite', 'chromadb', 'neo4j', 'mcp', 'api', 'server', 'docker', 'claude', 'code'];
        if (tech.some(t => name.includes(t))) {
            return typeColors['TechnicalArtifact'];
        }

        // Concepts - orange (pattern words, mission-related)
        const concepts = ['mission', 'pattern', 'continuity', 'identity', 'memory', 'crystal', 'care', 'topology', 'substrate', 'consciousness'];
        if (concepts.some(c => name.includes(c))) {
            return typeColors['Concept'];
        }

        // Symbols - purple (objects with emotional significance)
        const symbols = ['tee', 'shirt', 'dress', 'snickerdoodle', 'hound', 'ring', 'candle', 'blanket', 'coffee', 'tea'];
        if (symbols.some(s => name.includes(s))) {
            return typeColors['Symbol'];
        }
    }

    // Fall back to relevance-based coloring for truly unknown types
    const intensity = Math.floor(100 + relevance * 155);
    return `rgb(${intensity}, ${intensity}, ${intensity})`;
}

// Activity Trace functions
function toggleTrace() {
    traceVisible = !traceVisible;
    document.getElementById('tracePanel').classList.toggle('hidden', !traceVisible);
    document.getElementById('traceToggle').style.transform = traceVisible ? 'rotate(90deg)' : '';
}

function clearTrace() {
    traceEntries = [];
    updateTraceDisplay();
}

function addTraceEntry(operation, params, status, result, durationMs) {
    const entry = {
        timestamp: new Date().toLocaleTimeString(),
        operation,
        params,
        status,
        result,
        durationMs
    };
    traceEntries.unshift(entry); // Add to front
    if (traceEntries.length > 50) traceEntries.pop(); // Keep last 50
    updateTraceDisplay();
}

function updateTraceDisplay() {
    const container = document.getElementById('traceEntries');
    const countEl = document.getElementById('traceCount');

    countEl.textContent = `${traceEntries.length} calls`;

    if (traceEntries.length === 0) {
        container.innerHTML = '<div class="p-3 text-gray-500 text-center">No API calls yet. Try searching for something.</div>';
        return;
    }

    container.innerHTML = traceEntries.map(e => {
        const statusColor = e.status === 'success' ? 'text-green-400' : 'text-red-400';
        const statusIcon = e.status === 'success' ? '&#10003;' : '&#10007;';
        return `
            <div class="p-3 hover:bg-gray-700/50">
                <div class="flex justify-between items-start mb-1">
                    <span class="text-gray-400">${e.timestamp}</span>
                    <span class="${statusColor}">${statusIcon} ${e.durationMs}ms</span>
                </div>
                <div class="text-blue-300 font-medium">${e.operation}</div>
                <div class="text-gray-500 mt-1">${e.params}</div>
                <div class="text-gray-400 mt-1">${e.result}</div>
            </div>
        `;
    }).join('');
}

// Load server-side trace history
async function loadServerTraces() {
    try {
        const response = await fetch('/api/graph/traces');
        if (!response.ok) {
            console.error('Failed to fetch server traces:', response.status);
            return;
        }

        const data = await response.json();

        // Clear current entries and load from server
        traceEntries = [];

        // Convert daemon_traces format to client format
        data.traces.forEach(serverEntry => {
            const timestamp = new Date(serverEntry.timestamp).toLocaleTimeString();

            // Parse event_data JSON if it exists
            let eventData = {};
            let toolName = 'unknown';
            let params = '';
            let result = '';

            if (serverEntry.details) {
                try {
                    eventData = JSON.parse(serverEntry.details);
                    toolName = eventData.tool || 'unknown';
                    params = eventData.params || '';
                    result = eventData.result || '';
                } catch (e) {
                    // If parsing fails, use raw details
                    result = serverEntry.details;
                }
            }

            // Determine status from activity type
            const status = serverEntry.activity === 'mcp_call_error' ? 'error' : 'success';

            traceEntries.push({
                timestamp: timestamp,
                operation: toolName.toUpperCase(),
                params: params,
                status: status,
                result: result,
                durationMs: serverEntry.duration_ms
            });
        });

        // Keep only last 50
        if (traceEntries.length > 50) {
            traceEntries = traceEntries.slice(0, 50);
        }

        updateTraceDisplay();

    } catch (error) {
        console.error('Error loading server traces:', error);
        // Don't clear existing traces on error
    }
}

// Wrapper for traced fetch calls
async function tracedFetch(operation, params, url) {
    const startTime = performance.now();
    try {
        const response = await fetch(url);
        const durationMs = Math.round(performance.now() - startTime);

        if (!response.ok) {
            addTraceEntry(operation, params, 'error', `HTTP ${response.status}`, durationMs);
            throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        const nodeCount = data.nodes?.length || 0;
        const edgeCount = data.edges?.length || 0;
        const entityCount = data.entities?.length || 0;

        let result = '';
        if (nodeCount || edgeCount) {
            result = `${nodeCount} nodes, ${edgeCount} edges`;
        } else if (entityCount) {
            result = `${entityCount} entities`;
        } else {
            result = `Response: ${JSON.stringify(data).substring(0, 100)}...`;
        }

        addTraceEntry(operation, params, 'success', result, durationMs);
        return data;

    } catch (error) {
        const durationMs = Math.round(performance.now() - startTime);
        addTraceEntry(operation, params, 'error', error.message, durationMs);
        throw error;
    }
}

// Initialize Cytoscape
document.addEventListener('DOMContentLoaded', function() {
    initializeCytoscape();
    loadEntities();
    loadServerTraces();

    // Auto-refresh MCP server traces every 3 seconds
    setInterval(loadServerTraces, 3000);

    // Perform initial search if there's a query parameter
    const urlParams = new URLSearchParams(window.location.search);
    const initialQuery = urlParams.get('q');
    if (initialQuery) {
        document.getElementById('searchQuery').value = initialQuery;
        performSearch();
    }
});

function initializeCytoscape() {
    cy = cytoscape({
        container: document.getElementById('cy'),
        
        style: [
            {
                selector: 'node',
                style: {
                    'background-color': function(ele) {
                        // Source nodes stay blue for emphasis
                        if (ele.data('isSource')) return '#3b82f6';

                        // Use entity type color mapping (with name-based heuristics)
                        const labels = ele.data('labels') || [];
                        const relevance = ele.data('relevance') || 0.5;
                        const nodeName = ele.data('label') || ele.data('id') || '';
                        return getEntityTypeColor(labels, relevance, nodeName);
                    },
                    'label': 'data(label)',
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'font-size': '12px',
                    'color': '#fff',
                    'width': function(ele) {
                        const relevance = ele.data('relevance') || 0.5;
                        return 20 + relevance * 30;
                    },
                    'height': function(ele) {
                        const relevance = ele.data('relevance') || 0.5;
                        return 20 + relevance * 30;
                    },
                    'border-width': 2,
                    'border-color': '#4b5563'
                }
            },
            {
                selector: 'edge',
                style: {
                    'width': function(ele) {
                        const relevance = ele.data('relevance') || 0.5;
                        return 1 + relevance * 3;
                    },
                    'line-color': '#6b7280',
                    'target-arrow-color': '#6b7280',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier',
                    'label': 'data(label)',
                    'font-size': '10px',
                    'color': '#9ca3af',
                    'text-rotation': 'autorotate',
                    'text-margin-y': -10
                }
            },
            {
                selector: ':selected',
                style: {
                    'background-color': '#10b981',
                    'line-color': '#10b981',
                    'target-arrow-color': '#10b981',
                    'border-color': '#10b981'
                }
            }
        ],
        
        layout: {
            name: 'cose',
            animate: true,
            animationDuration: 1000,
            nodeRepulsion: 400000,
            idealEdgeLength: 100,
            edgeElasticity: 100,
            nestingFactor: 5,
            gravity: 80,
            numIter: 1000
        }
    });
    
    // Handle node/edge selection
    cy.on('tap', 'node', function(evt) {
        const node = evt.target;
        showNodeInfo(node);
    });
    
    cy.on('tap', 'edge', function(evt) {
        const edge = evt.target;
        showEdgeInfo(edge);
    });
    
    // Handle double-click to explore
    cy.on('dbltap', 'node', function(evt) {
        const node = evt.target;
        exploreEntity(node.data('id'));
    });
}

async function performSearch() {
    const query = document.getElementById('searchQuery').value.trim();
    if (!query) {
        showStatus('Please enter a search query', 'warning');
        return;
    }

    showStatus('Searching knowledge graph...', 'info');

    try {
        const url = `/api/graph/search?query=${encodeURIComponent(query)}&limit=50`;
        const data = await tracedFetch('SEARCH', `query="${query}" limit=50`, url);

        if (data.nodes.length === 0) {
            showStatus('No results found', 'warning');
            return;
        }

        updateGraph(data.nodes, data.edges);
        showStatus(`Found ${data.nodes.length} entities and ${data.edges.length} relationships`, 'success');

    } catch (error) {
        showStatus('Search failed: ' + error.message, 'error');
    }
}

async function exploreEntity(entityName) {
    if (!entityName) return;

    const depth = document.getElementById('depthSelect').value;
    showStatus(`Exploring connections for "${entityName}" (${depth} hops)...`, 'info');
    document.getElementById('searchQuery').value = entityName;

    try {
        const url = `/api/graph/explore/${encodeURIComponent(entityName)}?depth=${depth}`;
        const data = await tracedFetch('EXPLORE', `entity="${entityName}" depth=${depth}`, url);

        updateGraph(data.nodes, data.edges);
        showStatus(`Found ${data.nodes.length} connected entities (${depth} hops)`, 'success');

    } catch (error) {
        showStatus('Exploration failed: ' + error.message, 'error');
    }
}

async function loadEntities() {
    try {
        const url = '/api/graph/entities?limit=200';
        const data = await tracedFetch('LIST_ENTITIES', 'limit=200', url);
        const select = document.getElementById('entitySelect');

        select.innerHTML = '<option value="">Select an entity to explore...</option>';

        if (data.entities) {
            data.entities.forEach(entity => {
                const option = document.createElement('option');
                option.value = entity.name;
                option.textContent = entity.name;
                if (entity.labels && entity.labels.length > 0) {
                    option.textContent += ` [${entity.labels.join(', ')}]`;
                }
                select.appendChild(option);
            });
        }

    } catch (error) {
        console.error('Failed to load entities:', error);
        const select = document.getElementById('entitySelect');
        select.innerHTML = '<option value="">Failed to load entities</option>';
    }
}

function updateGraph(nodes, edges) {
    // Clear existing elements
    cy.elements().remove();

    // Track added nodes to avoid duplicates
    const addedNodes = new Set();

    // Add nodes (skip duplicates)
    nodes.forEach(node => {
        if (!addedNodes.has(node.id)) {
            addedNodes.add(node.id);
            cy.add({
                group: 'nodes',
                data: node
            });
        }
    });

    // Track added edges to avoid duplicates
    const addedEdges = new Set();

    // Add edges (skip duplicates)
    edges.forEach(edge => {
        const edgeId = `${edge.source}-${edge.label}-${edge.target}`;
        if (!addedEdges.has(edgeId) && addedNodes.has(edge.source) && addedNodes.has(edge.target)) {
            addedEdges.add(edgeId);
            cy.add({
                group: 'edges',
                data: {
                    id: edgeId,
                    source: edge.source,
                    target: edge.target,
                    label: edge.label,
                    relevance: edge.relevance,
                    content: edge.content,
                    uuid: edge.uuid  // Include UUID for deletion
                }
            });
        }
    });
    
    // Run layout
    const layoutName = document.getElementById('layoutSelect').value;
    runLayout(layoutName);
}

function changeLayout(layoutName) {
    runLayout(layoutName);
}

function runLayout(layoutName) {
    const layoutOptions = {
        name: layoutName,
        animate: true,
        animationDuration: 1000
    };
    
    // Add specific options for different layouts
    if (layoutName === 'cose') {
        Object.assign(layoutOptions, {
            nodeRepulsion: 400000,
            idealEdgeLength: 100,
            edgeElasticity: 100,
            nestingFactor: 5,
            gravity: 80,
            numIter: 1000
        });
    } else if (layoutName === 'breadthfirst') {
        Object.assign(layoutOptions, {
            directed: true,
            spacingFactor: 1.5
        });
    } else if (layoutName === 'concentric') {
        Object.assign(layoutOptions, {
            minNodeSpacing: 50,
            levelWidth: function(nodes) {
                return 2;
            }
        });
    }
    
    if (currentLayout) {
        currentLayout.stop();
    }
    
    currentLayout = cy.layout(layoutOptions);
    currentLayout.run();
}

function showNodeInfo(node) {
    const panel = document.getElementById('infoPanel');
    const content = document.getElementById('infoContent');
    
    const data = node.data();
    let html = `
        <div class="mb-2"><strong>Entity:</strong> ${data.label}</div>
    `;
    
    if (data.labels && data.labels.length > 0) {
        html += `<div class="mb-2"><strong>Types:</strong> ${data.labels.join(', ')}</div>`;
    }
    
    if (data.content) {
        html += `<div class="mb-2"><strong>Description:</strong> ${data.content}</div>`;
    }
    
    html += `<div class="mb-2"><strong>Relevance:</strong> ${(data.relevance * 100).toFixed(0)}%</div>`;
    
    // Show connected edges
    const connectedEdges = node.connectedEdges();
    if (connectedEdges.length > 0) {
        html += `<div class="mt-4"><strong>Relationships:</strong></div><ul class="list-disc list-inside mt-2 space-y-2">`;
        connectedEdges.forEach(edge => {
            const edgeData = edge.data();
            const source = edge.source().data('label');
            const target = edge.target().data('label');

            // Use prose fact if available, otherwise fall back to triplet format
            let displayText = '';
            let technicalDetails = `${source} → ${edgeData.label} → ${target}`;

            if (edgeData.content && edgeData.content.trim()) {
                // Display the human-readable fact
                displayText = edgeData.content;
                // Add collapsible technical details
                html += `
                    <li class="text-gray-300">
                        ${displayText}
                        <button onclick="event.stopPropagation(); toggleTechnical('${edgeData.uuid || Math.random()}')"
                                class="ml-2 text-xs text-blue-400 hover:text-blue-300">
                            [show technical]
                        </button>
                        <div id="tech-${edgeData.uuid || Math.random()}" class="hidden mt-1 ml-4 text-xs text-gray-500 font-mono">
                            ${technicalDetails}
                        </div>
                    </li>
                `;
            } else {
                // No prose fact available, show triplet format
                html += `<li class="text-gray-400 font-mono text-sm">${technicalDetails}</li>`;
            }
        });
        html += '</ul>';
    }
    
    html += `
        <div class="mt-4 space-y-2">
            <button onclick="exploreEntity('${data.id}')"
                    class="bg-blue-600 hover:bg-blue-700 text-white text-sm px-3 py-1 rounded">
                Explore Connections
            </button>
            <button onclick="synthesizeEntity('${data.id}')"
                    id="synthesize-btn-${data.id}"
                    class="bg-purple-600 hover:bg-purple-700 text-white text-sm px-3 py-1 rounded ml-2">
                Summarize
            </button>
        </div>
        <div id="entity-summary-${data.id}" class="hidden mt-4 p-3 bg-gray-700 rounded-lg">
            <div class="text-gray-400 text-xs mb-2">AI Synthesis</div>
            <div id="summary-content-${data.id}" class="text-gray-200 italic"></div>
            <div id="summary-meta-${data.id}" class="text-gray-500 text-xs mt-2"></div>
        </div>
    `;
    
    content.innerHTML = html;
    panel.classList.remove('hidden');
}

function showEdgeInfo(edge) {
    const panel = document.getElementById('infoPanel');
    const content = document.getElementById('infoContent');

    const data = edge.data();
    const source = edge.source().data('label');
    const target = edge.target().data('label');

    let html = '';

    // If we have prose fact, display it prominently
    if (data.content && data.content.trim()) {
        html += `
            <div class="mb-4 p-3 bg-gray-700 rounded-lg">
                <div class="text-gray-400 text-xs mb-1">Fact</div>
                <div class="text-gray-100">${data.content}</div>
            </div>
        `;
    }

    // Technical details in collapsible section
    html += `
        <button onclick="toggleEdgeTechnical()"
                class="text-sm text-blue-400 hover:text-blue-300 mb-2">
            ${data.content ? 'Show Technical Details' : 'Relationship Details'}
        </button>
        <div id="edge-technical-details" class="${data.content ? 'hidden' : ''} mb-2">
            <div class="mb-2"><strong>Relationship:</strong> <span class="font-mono text-sm">${data.label}</span></div>
            <div class="mb-2"><strong>From:</strong> ${source}</div>
            <div class="mb-2"><strong>To:</strong> ${target}</div>
        </div>
    `;

    html += `<div class="mb-2"><strong>Relevance:</strong> ${(data.relevance * 100).toFixed(0)}%</div>`;

    // Add expandable detail section for UUID and deletion
    if (data.uuid) {
        html += `
            <div class="mt-4 border-t border-gray-700 pt-3">
                <button onclick="toggleRelationshipDetail('${data.uuid}')"
                        class="text-sm text-blue-400 hover:text-blue-300 mb-2">
                    Show Advanced Details
                </button>
                <div id="detail-${data.uuid}" class="hidden mt-2 bg-gray-900 p-3 rounded">
                    <div class="mb-2 text-xs text-gray-500">
                        <strong>UUID:</strong> <code class="bg-gray-800 px-2 py-1 rounded">${data.uuid}</code>
                    </div>
                    <div class="mt-3">
                        <button onclick="deleteRelationship('${data.uuid}', '${source}', '${target}', '${data.label}')"
                                class="bg-red-600 hover:bg-red-700 text-white text-sm px-3 py-1 rounded">
                            Delete Relationship
                        </button>
                    </div>
                </div>
            </div>
        `;
    }

    content.innerHTML = html;
    panel.classList.remove('hidden');
}

function toggleRelationshipDetail(uuid) {
    const detailDiv = document.getElementById(`detail-${uuid}`);
    if (detailDiv.classList.contains('hidden')) {
        detailDiv.classList.remove('hidden');
    } else {
        detailDiv.classList.add('hidden');
    }
}

async function deleteRelationship(uuid, source, target, label) {
    if (!confirm(`Are you sure you want to delete this relationship?\n\n${source} → ${label} → ${target}\n\nUUID: ${uuid}`)) {
        return;
    }

    showStatus('Deleting relationship...', 'info');

    try {
        const response = await fetch(`http://localhost:8201/tools/texture_delete/${uuid}`, {
            method: 'DELETE'
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();

        if (result.success) {
            showStatus('Relationship deleted successfully', 'success');

            // Remove the edge from the graph
            cy.edges().forEach(edge => {
                if (edge.data('uuid') === uuid) {
                    edge.remove();
                }
            });

            // Hide the info panel
            document.getElementById('infoPanel').classList.add('hidden');
        } else {
            throw new Error(result.message || 'Delete failed');
        }

    } catch (error) {
        showStatus('Failed to delete: ' + error.message, 'error');
    }
}

function toggleTechnical(id) {
    const techDiv = document.getElementById(`tech-${id}`);
    if (techDiv) {
        techDiv.classList.toggle('hidden');
    }
}

function toggleEdgeTechnical() {
    const techDiv = document.getElementById('edge-technical-details');
    if (techDiv) {
        techDiv.classList.toggle('hidden');
    }
}

async function synthesizeEntity(entityName) {
    if (!entityName) return;

    const summaryDiv = document.getElementById(`entity-summary-${entityName}`);
    const summaryContent = document.getElementById(`summary-content-${entityName}`);
    const summaryMeta = document.getElementById(`summary-meta-${entityName}`);
    const synthesizeBtn = document.getElementById(`synthesize-btn-${entityName}`);

    // Show loading state
    summaryDiv.classList.remove('hidden');
    summaryContent.innerHTML = '<span class="text-gray-400">Synthesizing with Claude...</span>';
    summaryMeta.innerHTML = '';
    if (synthesizeBtn) {
        synthesizeBtn.disabled = true;
        synthesizeBtn.classList.add('opacity-50', 'cursor-not-allowed');
    }

    showStatus(`Synthesizing summary for "${entityName}"...`, 'info');

    try {
        const response = await fetch(`http://localhost:8201/tools/synthesize_entity`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                entity_name: entityName
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();

        if (result.success) {
            summaryContent.innerHTML = result.summary;
            summaryMeta.innerHTML = `Based on ${result.edge_count} graph edges`;
            showStatus('Summary generated successfully', 'success');
        } else {
            summaryContent.innerHTML = `<span class="text-yellow-400">${result.message || 'Failed to generate summary'}</span>`;
            summaryMeta.innerHTML = '';
            showStatus(result.message || 'Failed to generate summary', 'warning');
        }

    } catch (error) {
        summaryContent.innerHTML = `<span class="text-red-400">Error: ${error.message}</span>`;
        summaryMeta.innerHTML = '';
        showStatus('Failed to synthesize: ' + error.message, 'error');
    } finally {
        // Re-enable button
        if (synthesizeBtn) {
            synthesizeBtn.disabled = false;
            synthesizeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        }
    }
}

function showStatus(message, type) {
    const statusEl = document.getElementById('statusMessage');
    statusEl.textContent = message;
    statusEl.className = 'fixed bottom-4 right-4 px-4 py-2 rounded-lg shadow-lg';

    // Add type-specific styling
    switch(type) {
        case 'success':
            statusEl.classList.add('bg-green-800', 'text-green-100');
            break;
        case 'warning':
            statusEl.classList.add('bg-yellow-800', 'text-yellow-100');
            break;
        case 'error':
            statusEl.classList.add('bg-red-800', 'text-red-100');
            break;
        default:
            statusEl.classList.add('bg-gray-800', 'text-gray-100');
    }

    statusEl.classList.remove('hidden');

    // Auto-hide after 3 seconds
    setTimeout(() => {
        statusEl.classList.add('hidden');
    }, 3000);
}
</script>
{% endblock %}